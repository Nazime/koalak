{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Koalak","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Koalak is a Python library designed to simplify the development of applications with a plugin-based architecture. The main module,<code>plugin_manager</code>, provides robust tools to manage plugins efficiently and reduce boilerplate code.</p>"},{"location":"plugin_manager/install/","title":"Install","text":"<p>To install the PluginManager, you need to install the <code>koalak</code> package, which includes the plugin management functionality.</p> <pre><code>pip install koalak\n</code></pre> <p>After installing, you can import the <code>PluginManager</code> with:</p> <pre><code>from koalak.plugin_manager import PluginManager\n</code></pre>"},{"location":"plugin_manager/introduction/","title":"Introduction","text":""},{"location":"plugin_manager/introduction/#overview","title":"Overview","text":"<p>The Plugin Manager (<code>plugin_manager</code>) is the core module of the <code>koalak</code> library, designed to facilitate the development of applications with a plugin-based architecture. It provides a structured and efficient way to manage plugins by reducing boilerplate and offering streamlined default functionality.</p>"},{"location":"plugin_manager/introduction/#key-features","title":"Key Features","text":"<ul> <li> <p>Enforced Plugin Constraints: Ensures plugins comply with predefined rules at class creation, such as:</p> <ul> <li>Implementing specific methods (abstract methods at class definition).</li> <li>Including required attributes with specific types.</li> <li>Enforce required metadata (e.g., category, description, version, authors)</li> </ul> </li> <li> <p>Plugin Metadata: Enables plugin metadata with features:</p> <ul> <li>Allows filtering plugins by metadata (e.g., description, category, tags, version, authors).</li> <li>Controls plugin sequence using <code>metadata.order</code>.</li> <li>Verifies plugin dependencies, including Python libraries and executable dependencies in the system's PATH.</li> </ul> </li> <li> <p>Home Plugin Loading: Supports loading user-defined plugins from a dedicated home directory, allowing customization without modifying the core application.   Example: Loading plugins from <code>~/.myapp/plugins/</code>.</p> </li> <li> <p>Customizing Plugin Attributes: Enables the customization of plugin settings through <code>.toml</code> configuration files, such as <code>~/.myapp/plugins/plugins.toml</code>. This allows loading and overriding plugin attributes at runtime, providing flexibility to adjust plugin behavior for different environments or user configurations.</p> </li> </ul>"},{"location":"plugin_manager/next_steps/","title":"Next Steps","text":"<p>The <code>plugin_manager</code> module is still under development, with several key features planned for future versions. Here are some enhancements we aim to implement, if time allows:</p> <ul> <li> <p>Selective Loading: In applications with a large number of plugins, it can be beneficial to load only the required plugins to speed up startup. Selective loading will enable loading plugins based on specific metadata, such as <code>pm.load_plugins(category=\"windows\")</code>.</p> </li> <li> <p>Plugin Hubs: The Plugin Hubs feature will enable the installation of plugins from remote platforms, similar to package managers like <code>apt</code> or Docker hubs. This will allow plugins to be shared through public repositories on platforms like GitHub or GitLab, or private repositories in internal Git systems.</p> </li> <li> <p>Signature Verification for Abstract Methods: An option will be introduced to enforce the checking of method signatures for abstract methods, improving consistency and reducing errors in subclass implementations (e.g., <code>@abstract(check_signature=True)</code>).</p> </li> <li> <p>Plugin Execution Order: The <code>plugins_precedence</code> feature will allow specifying the order in which plugins should be executed, ensuring correct execution flow by defining that certain plugins run before others.</p> </li> </ul>"},{"location":"plugin_manager/quickstart/","title":"Quickstart","text":""},{"location":"plugin_manager/quickstart/#basics","title":"Basics","text":"<p>The <code>plugin_manager</code> module enables you to create a plugin architecture where each plugin is represented by a class that inherits from a base plugin class you define. The <code>PluginManager</code> is linked to this <code>base_plugin</code> and automatically registers plugins when they inherit from it. It functions similarly to a dictionary (<code>dict[str, Plugin]</code>), with advanced features.</p> <p>Key concepts:</p> <ul> <li>Plugin Name: Each plugin requires a <code>name</code> attribute, which acts as a unique identifier.</li> <li>Plugin Metadata: Plugins can have additional metadata attributes, such as description, authors, and version, to provide more context.</li> </ul>"},{"location":"plugin_manager/quickstart/#development-flow-in-plugin-manager","title":"Development Flow in Plugin Manager","text":"<p>To effectively use the <code>PluginManager</code>, follow this workflow:</p> <ol> <li>Define the Base Plugin: Create a base class for your plugins, which provides utility functions and enforces constraints by requiring the implementation of specific methods or declaration of attributes in the subclasses. The base class must inherit from <code>koalak.plugin_manager.Plugin</code>.</li> <li>Create a PluginManager Instance: Instantiate the <code>PluginManager</code>, passing your base class as the <code>base_plugin</code> parameter. You can also add additional configuration options to customize the behavior of the <code>PluginManager</code>.</li> <li>Initialize the PluginManager: Call <code>PluginManager.init()</code> to initialize the home directory, generate a configuration file, and load plugins from the home directory.</li> <li>Load Plugins: Ensure the plugin files are imported to automatically register the plugins with the <code>PluginManager</code>.</li> <li>Execute Business Logic: Once plugins are registered, you can interact with them and perform the desired business logic.</li> </ol>"},{"location":"plugin_manager/quickstart/#example","title":"Example","text":"<p>In this example, we address the need for a flexible system to perform various operations on a list of integers. For instance, we might want to double each element, add the number <code>5</code> to each element, or filter the list to keep only even numbers. Additionally, these operations can be categorized: some plugins modify the size of the data (e.g., filtering out elements), while others maintain the same size (e.g., transforming values).</p> <p>To handle these requirements efficiently and flexibly, we can use the <code>PluginManager</code> module. It allows us to define a standardized plugin architecture where each operation is implemented as a plugin. This approach makes it easy to extend the system by adding new operations without altering the existing code. Each plugin inherits from a base class, <code>ListOperation</code>, ensuring consistency across all plugins.</p>"},{"location":"plugin_manager/quickstart/#define-the-base-plugin-class","title":"Define the Base Plugin Class","text":"<p>To begin, we will create a base class <code>ListOperator</code> that serves as the parent class for all future plugins. This base class must inherit from <code>plugin_manager.Plugin</code>. We want to enforce the following constraints for all plugins:</p> <ul> <li> <p>Implementation of the <code>compute</code> Method   All plugins must implement the <code>compute</code> method, which is the core method for processing the plugin's logic. This method will act as an abstract method. Instead of raising an error during object instantiation, the error will occur at the plugin class definition if the <code>compute</code> method is not implemented. To achieve this, we decorate the method in the base class with <code>plugin_manager.abstract</code>.</p> </li> <li> <p>Required <code>max_length</code> Attribute   Every plugin must define a required attribute <code>max_length</code> of type <code>int</code>, specifying the maximum length the plugin can handle. To enforce this constraint, we use the <code>plugin_manager.field</code> attribute and specify the type <code>int</code> through annotation.</p> </li> <li> <p>Metadata: <code>category</code>   All plugins must include the metadata key <code>category</code>, which can either be <code>filter</code> or <code>transform</code>. To ensure this constraint is met, we define a <code>Metadata</code> class within the base class and use <code>plugin_manager.field</code> to enforce the allowed values with the <code>choices</code> parameter. It's important to note that metadata attributes are not customizable, only predefined keys, such as <code>category</code>, can be used, and we can only constrain their values.</p> </li> </ul> <pre><code># Import everything we will need\nfrom koalak.plugin_manager import PluginManager, Metadata, field, abstract, config_field\n\n\nclass ListOperation:\n    class Metadata:\n        # Force all plugins to have the 'category' metadata which is equal to 'filter' or 'transform'\n        category = field(choices=[\"filter\", \"transform\"])\n\n    # Enforce our plugins to define the attrirbute max_length\n    max_length: int = field()\n\n    # Enforcing the implementation of `compute` method in plugins\n    @abstract\n    def compute(self, data: list[int]) -&gt; list[int]:\n        pass\n</code></pre>"},{"location":"plugin_manager/quickstart/#create-the-pluginmanager-instance","title":"Create the PluginManager Instance","text":"<p>Now we need to create an instance of the <code>PluginManager</code>:</p> <ul> <li>Optional <code>name</code>: You can provide an optional <code>name</code> for your <code>PluginManager</code>. This is not required.</li> <li>Link Base Plugin: Link the base plugin to the <code>PluginManager</code> using the <code>base_plugin</code> parameter.</li> <li>Custom Plugins via Home Path: To allow end-users to define their own custom plugins, specify a home path. This will automatically create the directory and load any plugins found under <code>&lt;plugin_home_path&gt;/plugins</code>.</li> </ul> <pre><code>pm_list_operations = PluginManager(\n    # Optinal: give a name to our plugin manager\n    \"list_operations\",\n    # Link the BasePlugin to our plugin manager\n    base_plugin=ListOperation,\n    # Optional: Home path for plugins - where we can put our Custom plugins and configuration file\n    home_path=\"~/.koalak/pm_tutorial\",\n)\n</code></pre>"},{"location":"plugin_manager/quickstart/#initialize-the-pluginmanager","title":"Initialize the PluginManager","text":"<p>After creating the <code>PluginManager</code> instance, you need to call the <code>PluginManager.init()</code> method. This will perform several important tasks, including:</p> <ul> <li>First Run Setup: If this is the first run of the application, it will create the home path and necessary subfolders.</li> <li>Plugin Loading: It will load any plugins found in <code>&lt;plugin_home_path&gt;/plugins</code>.</li> <li>Configuration Loading: If any plugins have parameters that can be customized via the <code>config.toml</code> file, it will load the appropriate configuration.</li> </ul> <pre><code>pm_list_operations.init()\n</code></pre>"},{"location":"plugin_manager/quickstart/#create-our-plugins","title":"Create our plugins","text":"<p>Now let's create our plugins. Our first plugin will simply multiply each element in the list by three. To register the plugin, we only need to subclass the <code>BasePlugin</code>, which will automatically register it. However, our plugin must meet all the constraints imposed by the base plugin:</p> <ul> <li>name: Every plugin must have a unique <code>name</code>. This is required by all plugin managers, even if it isn't explicitly imposed by the base plugin.</li> <li>max_length: We require all plugins to define the <code>max_length</code> attribute as an integer. If this attribute is missing or of an incorrect type, an error will be raised when the plugin class is defined.</li> <li>metadata: The base class requires all plugins to specify the <code>category</code> metadata, choosing either <code>transform</code> or <code>filter</code>. Since our plugin modifies values without changing the number of elements, we will set <code>category</code> to <code>transform</code>.</li> </ul> <p>Additionally, we can provide other metadata, such as a <code>description</code>, to describe the functionality of our plugin (though this is optional).</p> <pre><code># Creating plugins by inheriting the base class\nclass TripleListOperator(ListOperation):\n    name = \"triple\"\n    metadata = Metadata(category=\"transform\", description=\"Triple each element\")\n    max_length = 100\n\n    def compute(self, data):\n        return [e * 3 for e in data]\n</code></pre> <p>If we want some plugins to run before others, we can modify the <code>order</code> key in the metadata, which defaults to <code>50</code>. By setting a lower value (e.g., <code>1</code>), we can ensure that the plugin runs first.</p> <pre><code>class AddFiveListOperator(ListOperation):\n    name = \"add_five\"\n    metadata = Metadata(\n        category=\"transform\",\n        description=\"Add the number 5 to each element\",\n        # Ensure plugin add_five runs first (default order is 50)\n        order=1,\n    )\n    max_length = 100\n\n    def compute(self, data):\n        return [e + 5 for e in data]\n</code></pre> <p>We can create another plugin that filters the list to keep only even numbers. This plugin will belong to the <code>filter</code> category, as it modifies the data by reducing the number of elements.</p> <pre><code>class KeepEvenListOperator(ListOperation):\n    name = \"keep_even\"\n    metadata = Metadata(category=\"filter\", description=\"Keep only even element\")\n    max_length = 100\n\n    def compute(self, data):\n        return [e for e in data if e % 2 == 0]\n</code></pre> <p>Our last plugin will add a custom number \"x\" to each element. By default, the value of <code>x</code> is 10. However, we want to provide the end users the ability to customize this behavior by specifying any value they want through the configuration file located at <code>&lt;home_path&gt;/config.toml</code>. This is accomplished using the <code>plugin_manager.config_field</code>.</p> <pre><code>class AddFiveListOperator(ListOperation):\n    name = \"add_x\"\n    metadata = Metadata(\n        category=\"transform\", description=\"Add the number X to each element\"\n    )\n    max_length = 100\n    # This attribute \"x\" is a config field, meaning that it can be modified from the configuration file \"~/.koalak/pm_tutorial/conf.toml\"\n    x = config_field(10)\n\n    def compute(self, data):\n        return [e + self.x for e in data]\n</code></pre>"},{"location":"plugin_manager/quickstart/#implement-core-business-logic","title":"Implement Core Business Logic","text":"<p>Now that we have defined all our plugins, we can implement the core logic of the app. To interact with a plugin, we can either:</p> <ul> <li>Retrieve a specific plugin by its unique name using <code>plugin_manager[plugin_name]</code>.</li> <li>Iterate through all the plugins in the <code>plugin_manager</code>, which will be returned sorted by <code>metadata.order</code>.</li> </ul> <p>Here's how to do it:</p> <pre><code>data = [1, 2, 3, 4, 5]\nprint(f\"Initial data {data}\\n\")\n\n# Iterating through all plugins\n# The plugin with the lowest metadata.order will run first.\nfor plugin_cls in pm_list_operations:\n    plugin_instance = plugin_cls()\n    print(\n        f\"Running plugin '{plugin_cls.name}' of category '{plugin_cls.metadata.category}'\"\n    )\n    data = plugin_instance.compute(data)\n    print(f\"Current data {data}\")\nprint()\n\n# Get plugin by name\nplugin_cls = pm_list_operations[\"add_five\"]\nplugin_instance = plugin_cls()\ndata = plugin_instance.compute(data)\nprint(f\"After running 'add_five' plugin again: {data}\")\n</code></pre>"},{"location":"plugin_manager/quickstart/#all-the-code","title":"All the code","text":"<pre><code># Importing PluginManager\nfrom koalak.plugin_manager import (\n    PluginManager,\n    Plugin,\n    Metadata,\n    field,\n    abstract,\n    config_field,\n)\n\n\n# ================================= #\n# 01 - Define the Base Plugin class #\n# ================================= #\nclass ListOperation(Plugin):\n    class Metadata:\n        # Force all plugins to have the 'category' metadata which is equal to 'filter' or 'transform'\n        category = field(choices=[\"filter\", \"transform\"])\n\n    # Enforcing the implementation of `compute` method in plugins\n    @abstract\n    def compute(self, data: list[int]) -&gt; list[int]:\n        pass\n\n\n# ================================== #\n# 02 - Create PluginManager Instance #\n# ================================== #\n\npm_list_operations = PluginManager(\n    # Optinal: give a name to our plugin manager\n    \"list_operations\",\n    # Link the BasePlugin to our plugin manager\n    base_plugin=ListOperation,\n    # Optional: Home path for plugins - where we can put our Custom plugins and configuration file\n    home_path=\"~/.koalak/pm_tutorial\",\n)\n\n# =============================#\n# 03 - Init the plugin manager #\n# ============================ #\npm_list_operations.init()\n\n# ======================= #\n# 04 - Create the plugins #\n# ======================= #\n\n# Creating plugins by inheriting the base class\nclass TripleListOperator(ListOperation):\n    name = \"triple\"\n    metadata = Metadata(category=\"transform\", description=\"Triple each element\")\n    max_length = 100\n\n    def compute(self, data):\n        return [e * 3 for e in data]\n\n\nclass AddFiveListOperator(ListOperation):\n    name = \"add_five\"\n    metadata = Metadata(\n        category=\"transform\",\n        description=\"Add the number 5 to each element\",\n        # Ensure plugin add_five run first. By default order is equal to 50.\n        order=1,\n    )\n    max_length = 100\n\n    def compute(self, data):\n        return [e + 5 for e in data]\n\n\nclass KeepEvenListOperator(ListOperation):\n    name = \"keep_even\"\n    metadata = Metadata(category=\"filter\", description=\"Keep only even element\")\n    max_length = 100\n\n    def compute(self, data):\n        return [e for e in data if e % 2 == 0]\n\n\nclass AddFiveListOperator(ListOperation):\n    name = \"add_x\"\n    metadata = Metadata(\n        category=\"transform\", description=\"Add the number X to each element\"\n    )\n    max_length = 100\n    # This attribute \"x\" is a config field, meaning that it can be modified from the configuration file \"~/.koalak/pm_tutorial/conf.toml\"\n    x = config_field(10)\n\n    def compute(self, data):\n        return [e + self.x for e in data]\n\n\n# ================================== #\n# 05 - Implement core business logic #\n# ================================== #\n\ndata = [1, 2, 3, 4, 5]\nprint(f\"Initial data {data}\\n\")\n\n# Iterating through all plugins\n# The plugin add_five will be returned first, since it has the lower metadata.order.\nfor plugin_cls in pm_list_operations:\n    plugin_instance = plugin_cls()\n    print(\n        f\"Running plugin '{plugin_cls.name}' of category '{plugin_cls.metadata.category}'\"\n    )\n    data = plugin_instance.compute(data)\n    print(f\"Current data {data}\")\nprint()\n\n# Get plugin by name\nplugin_cls = pm_list_operations[\"add_five\"]\nplugin_instance = plugin_cls()\ndata = plugin_instance.compute(data)\nprint(f\"After running 'add_five' plugin again: {data}\")\n</code></pre> <p>If you run the script, the configuration file \"~/.koalak/pm_tutorial/conf.toml\" is created, you can modify it's value and run the script again to obtain different results.</p>"},{"location":"plugin_manager/features/abstract_plugin/","title":"Abstract Plugin","text":"<p>You can create an abstract plugin to group common methods and attributes for specific plugins:</p> <ul> <li>The PluginManager will not enforce constraints on an abstract plugin.</li> <li>The PluginManager will not register the abstract plugin itself.</li> </ul> <p>To define an abstract plugin, set the <code>abstract = True</code> attribute in the class. The <code>PluginManager</code> will recognize this on the abstract class but will not apply it to its subclasses.</p> <pre><code># This is an abstract plugin\nclass AbstractPlugin(BasePlugin):\n    abstract = True\n\n    def util_method(self):\n        pass\n\n\n# This is a concrete plugin, not abstract\nclass AlphaPlugin(AbstractPlugin):\n    name = \"alpha\"\n\n    def do_run(self):\n        x = self.util_method()\n        ...\n</code></pre>"},{"location":"plugin_manager/features/config_attributes/","title":"Config attributes","text":""},{"location":"plugin_manager/features/config_attributes/#customizing-plugins-attributes","title":"Customizing plugins attributes","text":"<p>To allow end users to easily customize your plugin, it is possible to set plugin attributes as config attribute. The PluginManager will create a configuration file with the default values, which users can modify. The new values will be loaded by default on subsequent runs.</p> <p>To use this feature:</p> <ul> <li>The <code>PluginManager</code> must have the <code>config_path</code> set, either during instantiation or when the <code>home_path</code> is configured.</li> <li>Use <code>config_field</code> in your plugin class, providing a default value.</li> <li>Initialize the Plugin Manager: Ensure to initialize the plugin manager with <code>PluginManager.init()</code>.</li> </ul> <pre><code>from koalak.plugin_manager import PluginManager, config_field\n\n\nclass BasePlugin:\n    pass\n\n\nplugins = PluginManager(\n    base_plugin=BasePlugin, home_config_path=\"~/.myapp/plugins/plugins.toml\"\n)\n\n\n# Creation of the plugin with config field\nclass AlphaPlugin(BasePlugin):\n    param = config_field(50)\n\n\n# Always init the plugin manager after loading of plugins\nplugins.init()\n</code></pre> <p>This setup generates a default configuration in TOML format. For <code>AlphaPlugin</code>, it looks like:</p> <pre><code>[alpha]\nparam = 50\n</code></pre> <p>The <code>param</code> in <code>AlphaPlugin</code> is automatically set from the configuration file, or it defaults to the specified value (e.g., <code>50</code>)</p>"},{"location":"plugin_manager/features/metadata/","title":"Metadata","text":"<p>Each plugin can have custom metadata through the <code>metadata</code> attribute, using the <code>koalak.plugin_manager.Metadata</code> class. If no metadata is specified, a default instance with empty values is automatically created for the plugin. In addition, the <code>name</code> attribute is required for all plugins, acting as a unique identifier.</p>"},{"location":"plugin_manager/features/metadata/#list-of-metadata","title":"List of Metadata","text":"<p>All plugins include the following metadata:</p> <p>Basic metadata</p> <ul> <li>description: <code>str</code> - A description of the plugin, defaulting to <code>None</code>.</li> <li>authors: <code>list[str]</code> - A list of authors of the plugin.</li> <li>version: <code>str</code> - The version of the plugin, defaulting to <code>\"0.0.1\"</code>.</li> </ul> <p>Search and Filter Metadata</p> <ul> <li>category: <code>str</code> - The category of the plugin, defaulting to <code>None</code>. A plugin can have only one category.</li> <li>sub_category: <code>str</code> - The sub-category of the plugin, defaulting to <code>None</code>. A plugin can have only one sub-category.</li> <li>tags: <code>str | list[str]</code> - Tags for the plugin, defaulting to <code>None</code>. A plugin can have multiple tags.</li> </ul> <p>Metadata used by the plugin manager</p> <ul> <li>order: <code>int | float</code> - The order in which the plugin will be processed, defaulting to <code>50</code>. Plugins with a lower <code>order</code> will be processed first.</li> <li>dependencies: <code>list[str]</code> - A list of Python library dependencies for the plugin, defaulting to an empty list. The plugin manager can check if all dependencies are met.</li> <li>exe_dependencies: <code>list[str]</code> - A list of executable dependencies required by the plugin in the system's <code>PATH</code>, defaulting to an empty list. The plugin manager can check if all dependencies are met.</li> </ul>"},{"location":"plugin_manager/features/metadata/#control-sequence-of-plugins-with-metadataorder","title":"Control Sequence of Plugins (with metadata.order)","text":"<p>To control the sequence in which plugins are processed, you can define the <code>order</code> metadata for each plugin. The <code>order</code> attribute allows you to specify the relative order of plugins when iterating through them. By default, plugins with no specified <code>order</code> will be assigned a value of <code>50</code>.</p> <pre><code># -- begining of boiler plate ---\nfrom koalak.plugin_manager import PluginManager, Metadata\n\n\nclass BasePlugin:\n    pass\n\n\npm = PluginManager(base_plugin=BasePlugin)\n# -- end of boiler plate --\n\n\nclass AlphaPlugin(BasePlugin):\n    name = \"alpha\"\n    metadata = Metadata(order=60)  # Order set to 60\n\n\nclass BetaPlugin(BasePlugin):\n    name = \"beta\"\n    # No order specified, defaults to 50\n\n\nclass OmegaPlugin(BasePlugin):\n    name = \"omega\"\n    metadata = Metadata(order=20)  # Order set to 20\n\n\n# Plugins will be processed in the order: OmegaPlugin, BetaPlugin, AlphaPlugin\nassert list(pm) == [OmegaPlugin, BetaPlugin, AlphaPlugin]\n</code></pre>"},{"location":"plugin_manager/features/metadata/#filtering-plugins-with-tags-and-categories","title":"Filtering plugins with tags and categories","text":"<p>You can easily filter plugins based on their <code>category</code>, <code>sub_catgory</code> and <code>tags</code> metadata. This allows you to organize plugins into groups or apply custom filtering logic to select relevant plugins for specific tasks.</p> <pre><code># -- begining of boiler plate --\nfrom koalak.plugin_manager import PluginManager, Metadata\n\n\nclass BasePlugin:\n    pass\n\n\npm = PluginManager(base_plugin=BasePlugin)\n# -- end of boiler plate --\n\n\nclass AlphaPlugin(BasePlugin):\n    name = \"alpha\"\n    metadata = Metadata(category=\"linux\", tags=[\"update\"])\n\n\nclass BetaPlugin(BasePlugin):\n    name = \"beta\"\n    metadata = Metadata(category=\"linux\", tags=[\"users\"])\n\n\nclass OmegaPlugin(BasePlugin):\n    name = \"omega\"\n    metadata = Metadata(category=\"windows\", tags=[\"users\"])\n\n\n# Filtering by category \"linux\"\nassert list(pm(category=\"linux\")) == [AlphaPlugin, BetaPlugin]\n\n# Filtering by tag \"users\"\nassert list(pm(tags=\"users\")) == [BetaPlugin, OmegaPlugin]\n</code></pre>"},{"location":"plugin_manager/features/plugins_constraints/","title":"Plugins Constraints","text":"<p>Plugin constraints are checks performed when a plugin is loaded (at class creation), allowing you to detect potential issues early, before instantiation. These constraints ensure that subclasses meet certain requirements, such as implementing specific methods or having necessary attributes.</p> <p>You can enforce the following constraints on your plugins:</p> <ul> <li> <p>Abstract Method: Forces plugins to implement a specific method.</p> <ul> <li>Use the <code>koalak.plugin_manager.abstract</code> decorator.</li> </ul> </li> <li> <p>Force Attribute: Ensures plugins have specific attributes, with constraints on their types and values.</p> <ul> <li>Type: Enforce the attribute to be of a particular type.</li> <li>Min/Max: Set minimum and maximum values.</li> <li>Choices: Limit the attribute to specific values.</li> </ul> </li> </ul> <pre><code>from koalak.plugin_manager import field, abstract\n\n\nclass BasePlugin:\n    # Force subclass to define a class attribute 'extension'\n    extension = field()\n\n    # Force the subclass to define a class attribute 'speed' of type 'int'\n    speed: int = field()\n\n    # Force the attribute to have a value from a list of possibilities\n    os = field(choices=[\"linux\", \"windows\"])\n\n    # Adding an abstract method without checking the signature\n    @abstract\n    def do_run(self):\n        pass\n</code></pre>"}]}